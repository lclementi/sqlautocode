import sys, re, inspect
import logging
from util import emit
try:
    from cStringIO import StringIO
except ImportError:
    from StringIO import StringIO

import sqlalchemy
from sqlalchemy import MetaData
from sqlalchemy.ext.declarative import declarative_base, _deferred_relation
from sqlalchemy.orm import relation, backref, class_mapper, RelationProperty, Mapper

import config
import constants
from formatter import _repr_coltype_as


# lifted from http://www.daniweb.com/forums/thread70647.html
# (pattern, search, replace) regex english plural rules tuple
rule_tuple = (
('[ml]ouse$', '([ml])ouse$', '\\1ice'), 
('child$', 'child$', 'children'), 
('booth$', 'booth$', 'booths'), 
('foot$', 'foot$', 'feet'), 
('ooth$', 'ooth$', 'eeth'), 
('l[eo]af$', 'l([eo])af$', 'l\\1aves'), 
('sis$', 'sis$', 'ses'), 
('man$', 'man$', 'men'), 
('ife$', 'ife$', 'ives'), 
('eau$', 'eau$', 'eaux'), 
('lf$', 'lf$', 'lves'), 
('[xz]$', '$', 'es'), 
('[s]$', '$', ''), 
('[^aeioudgkprt]h$', '$', 'es'), 
('(qu|[^aeiou])y$', 'y$', 'ies'), 
('$', '$', 's')
)
 
def regex_rules(rules=rule_tuple):
    for line in rules:
        pattern, search, replace = line
        yield lambda word: re.search(pattern, word) and re.sub(search, replace, word)
 
def plural(noun):
    for rule in regex_rules():
        result = rule(noun)
        if result: 
            return result

def name2label(name, schema=None):
    """
    Convert a column name to a Human Readable name.
    borrowed from old TG fastdata code
    """
    # Create label from the name:
    #   1) Convert _ to Nothing
    #   2) Convert CamelCase to Camel Case
    #   3) Upcase first character of Each Word
    # Note: I *think* it would be thread-safe to
    #       memoize this thing.
    if schema:
        if name.startswith(schema+'.'):
            name = '.'.join(name.split('.')[1:])
    label = str(''.join([s.capitalize() for s in
               re.findall(r'([A-Z][a-z0-9]+|[a-z0-9]+|[A-Z0-9]+)', name)]))
    return label

header = """#autogenerated by sqlautocode

from sqlalchemy import *
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import relation

engine = create_engine('%s')
DeclarativeBase = declarative_base()
metadata = DeclarativeBase.metadata
metadata.bind = engine

"""

example = """#example on how to query your Schema
from sqlalchemy.orm import sessionmaker
session = sessionmaker(bind=engine)()
objs = session.query(%s).all()
print objs
"""

interactive = """
print 'Trying to start IPython shell...',
try:
    from IPython.Shell import IPShellEmbed
    print 'Success! Type <ctrl-d> to exit.'
    ipshell = IPShellEmbed()
    ipshell()
except:
    'Failed. please easy_install ipython'
"""

def column_repr(self):
    
    kwarg = []
    if self.key != self.name:
        kwarg.append( 'key')

    if hasattr(self, 'primary_key') and self.primary_key:
        self.primary_key = True
        kwarg.append( 'primary_key')

    if not self.nullable:
        kwarg.append( 'nullable')
    if self.onupdate:
        kwarg.append( 'onupdate')
    if self.default:
        kwarg.append( 'default')
    ks = ', '.join('%s=%r' % (k, getattr(self, k)) for k in kwarg)

    name = self.name

    if not hasattr(config, 'options') and config.options.generictypes:
        coltype = repr(self.type)
    elif type(self.type).__module__ == 'sqlalchemy.types':
        coltype = repr(self.type)
    else:
        # Try to 'cast' this column type to a cross-platform type
        # from sqlalchemy.types, dropping any database-specific type
        # arguments.
        for base in type(self.type).__mro__:
            if (base.__module__ == 'sqlalchemy.types' and
                base.__name__ in sqlalchemy.__all__):
                coltype = _repr_coltype_as(self.type, base)
                break
        # FIXME: if a dialect has a non-standard type that does not
        # derive from an ANSI type, there's no choice but to ignore
        # generic-types and output the exact type. However, import
        # headers have already been output and lack the required
        # dialect import.
        else:
            coltype = repr(self.type)

    data = {'name': self.name,
            'type': coltype,
            'constraints': ', '.join(["ForeignKey('%s')"%cn.target_fullname for cn in self.foreign_keys]),
            'args': ks and ks or '',
            }

    if data['constraints']:
        if data['constraints']: data['constraints'] = ', ' + data['constraints']
    if data['args']:
        if data['args']: data['args'] = ', ' + data['args']

    return constants.COLUMN % data

class ModelFactory(object):
    
    def __init__(self, config):
        self.config = config
        schema = getattr(self.config, 'schema', None)
        self._metadata = MetaData(bind=config.engine)
        kw = {}
        if schema:
            kw['schema'] = schema
            logging.info('Using schema... schema')
        logging.info('Reflecting database..')
        self._metadata.reflect(**kw)
        
        self.DeclarativeBase = declarative_base(metadata=self._metadata)

    def _table_repr(self, table):
        s = "%s = Table(u'%s', metadata,\n"%(table.name, table.name)
        for column in table.c:
            s += "    %s,\n"%column_repr(column)
        s+=")"
        return s
    
    def __repr__(self):
        tables = self.get_many_to_many_tables()
        models = self.models
        
        s = StringIO()
        engine = self.config.engine
        if not isinstance(engine, basestring):
            engine = str(engine.url)
        s.write(header%engine)
        for table in tables:
            s.write('%s = %s\n\n'%(table.name, self._table_repr(table)))
        
        for model in models:
            s.write(model.__repr__())
            s.write("\n\n")

        if self.config.example or self.config.interactive:
            s.write(example%models[0].__name__)
        if self.config.interactive:
            s.write(interactive)
        return s.getvalue()

    @property
    def tables(self):
        return self._metadata.tables.keys()
    
    @property
    def models(self):
        return [self.create_model(table) for table in self.get_non_many_to_many_tables()]
    
    def create_model(self, table):
        #partially borrowed from Jorge Vargas' code
        #http://dpaste.org/V6YS/
        
        model_name = name2label(table.name)
        class Temporal(self.DeclarativeBase):
            __table__ = table
            
            @classmethod
            def _relation_repr(cls, rel):
                target = rel.argument
                if target and inspect.isfunction(target):
                    target = target()
                if isinstance(target, Mapper):
                    target = target.class_
                target = target.__name__
                secondary = ''
                if rel.secondary:
                    secondary = ", secondary=%s"%rel.secondary.name
                backref=''
#                if rel.backref:
#                    backref=", backref='%s'"%rel.backref.key
                return "%s = relation('%s'%s%s)"%(rel.key, target, secondary, backref)
            
            @classmethod
            def __repr__(cls):
                mapper = class_mapper(cls)
                s = ""
                s += "class "+model_name+'(DeclarativeBase):\n'
                s += "    __tablename__ = '%s'\n\n"%table.name
                if hasattr(cls, '__table_args__'):
                    s+="    __table_args__ = %s"%cls.__table_args__
                s += "    #column definitions\n"
                for column in cls.__table__.c:
                    s += "    %s = %s\n"%(column.name, column_repr(column))
                s += "\n    #relation definitions\n"
                ess = s
                for prop in mapper.iterate_properties:
                    if isinstance(prop, RelationProperty):
                        s+='    %s\n'%cls._relation_repr(prop)
                return s

        #hack the class to have the right classname
        Temporal.__name__ = model_name
        
        #add in the schema
        if self.config.schema:
            Temporal.__table_args__ = {'schema':self.config.schema}

        #trick sa's model registry to think the model is the correct name
        if model_name != 'Temporal':
            Temporal._decl_class_registry[model_name] = Temporal._decl_class_registry['Temporal']
            del Temporal._decl_class_registry['Temporal']

        #add in single relations
        for column in self.get_foreign_keys(table):
            related_table = column.foreign_keys[0].column.table
            backref_name = plural(table.name)
            setattr(Temporal, related_table.name, _deferred_relation(Temporal, relation(name2label(related_table.name, self.config.schema), backref=backref(backref_name))))
        
        #add in many-to-many relations
        for join_table in self.get_related_many_to_many_tables(table.name):
            for column in join_table.columns:
                key = column.foreign_keys[0]
                if key.column.table is not table:
                    related_table = column.foreign_keys[0].column.table
#                    backref_name = plural(table.name)
                    setattr(Temporal, plural(related_table.name), _deferred_relation(Temporal, relation(name2label(related_table.name, self.config.schema), secondary=join_table)))
                    break;

        return Temporal

    def get_table(self, name):
        """(name) -> sqlalchemy.schema.Table
        get the table definition with the given table name
        """
        if hasattr(self.config, 'schema'):
            schema = self.config.schema
            if schema and not name.startswith(schema):
                name = '.'.join((schema, name))
        return self._metadata.tables[name]

    def get_foreign_keys(self, table):
        return [column for column in table.columns if len(column.foreign_keys)>0]

    def get_many_to_many_tables(self):
        if not hasattr(self, '_many_to_many_tables'):
            self._many_to_many_tables = [table for table in self._metadata.tables.values() if len(self.get_foreign_keys(table)) == 2 and len(table.c) == 2]
        return self._many_to_many_tables

    def get_non_many_to_many_tables(self):
        return [table for table in self._metadata.tables.values() if len(self.get_foreign_keys(table)) != 2 or len(table.c) != 2]
    
    def get_related_many_to_many_tables(self, table_name):
        tables = []
        src_table = self.get_table(table_name)
        for table in self.get_many_to_many_tables():
            for column in table.columns:
                key = column.foreign_keys[0]
                if key.column.table is src_table:
                    tables.append(table)
                    break
        return tables
